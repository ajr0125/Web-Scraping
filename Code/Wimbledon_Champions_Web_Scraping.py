# -*- coding: utf-8 -*-
"""Wimbledon Champions Web Scraping.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xpDlWSHFvKClzuMDM7gJ1W4V2LQqaAOg
"""

# Web Scraping Imports
from bs4 import BeautifulSoup
import requests

# Set the URL for the webpage containing Wimbledon Men's Singles Champions
url_men = 'https://en.wikipedia.org/wiki/List_of_Wimbledon_gentlemen%27s_singles_champions'

# Send an HTTP GET request to the URL to retrieve the page content
page_men = requests.get(url_men)

# Parse the retrieved page content with BeautifulSoup, specifying 'html' as the parser format
soup_men = BeautifulSoup(page_men.text, 'html')

# Find all <table> elements on the page and select the fourth one (index [3]), which contains the data we are looking for
table_men = soup_men.find_all('table')[3]

# Find all <th> (table header) elements within the selected table. which is where the column headers are
match_stat_titles_men = table_men.find_all('th')

# Create a list to hold the text content of each header element in match_stat_titles.
# For each title (header) in match_stat_titles, extract its text, remove any leading/trailing whitespace,
# and add it to the match_table_titles list
match_table_titles_men = [title.text.strip() for title in match_stat_titles_men]

# Eliminating superscript link citations from header and making Country Headers Unique
match_table_titles_men[len(match_table_titles_men)-1] = 'Score in the final'
match_table_titles_men[len(match_table_titles_men)-3] = 'Country of Runner-up'
match_table_titles_men[len(match_table_titles_men)-5] = 'Country of Champion'

# Import pandas for dataframe usage
import pandas as pd

# Create dataframe with previously stored column titles
df_men = pd.DataFrame(columns = match_table_titles_men)

# Find all the rows in the table
column_data_men = table_men.find_all('tr')

# Loop through each row in column_data, starting from the second row (index 1)
# This skips the first row, which typically contains column headers.
for row in column_data_men[1:]:
    # Find all <td> elements (data cells) within the row, which contain the actual data for each column in that row
    row_data = row.find_all('td')
    # Extract and clean the text from each <td> element in the row, removing any extra whitespace, and store it in individual_row_data
    individual_row_data = [data.text.strip() for data in row_data]
    # Get the current number of rows in the DataFrame (length of df) to identify where to insert new data
    length = len(df_men)
    # Check if the number of columns in match_table_titles matches the number of data points in the row
    # If they match, this ensures data alignment, so add the row data to the DataFrame (accounts for rows missing elements like 2020 Wimbledon which was cancelled due to COVID)
    if len(match_table_titles_men) == len(individual_row_data):
        df_men.loc[length] = individual_row_data

df_men

# Repeat process for women's singles titles
url_women = 'https://en.wikipedia.org/wiki/List_of_Wimbledon_ladies%27_singles_champions'

page_women = requests.get(url_women)

soup_women = BeautifulSoup(page_women.text, 'html')

table_women = soup_women.find_all('table')[3]

match_stat_titles_women = table_women.find_all('th')

match_table_titles_women = [title.text.strip() for title in match_stat_titles_women]

match_table_titles_women[len(match_table_titles_women)-1] = 'Score in the final'
match_table_titles_women[0] = 'Year'
match_table_titles_women[len(match_table_titles_women)-3] = 'Country of Runner-up'
match_table_titles_women[len(match_table_titles_women)-5] = 'Country of Champion'

df_women = pd.DataFrame(columns = match_table_titles_women)

column_data_women = table_women.find_all('tr')

for row in column_data_women[1:]:
    row_data = row.find_all('td')
    individual_row_data = [data.text.strip() for data in row_data]

    length = len(df_women)
    if(len(match_table_titles_women) == len(individual_row_data)):
      df_women.loc[length] = individual_row_data

df_women

# Graphing Libraries to import
import seaborn as sns
import matplotlib.pyplot as plt

# Count the number of wins by country for men
wins_country_men = df_men['Country of Champion'].value_counts()

# Count the number of wins by country for women
wins_country_women = df_women['Country of Champion'].value_counts()

# Plot Pie chart for men
wins_country_men.plot(kind='pie', autopct='%1.1f%%', figsize=(8, 8), colors=sns.color_palette("Set2", len(wins_country_men)))
plt.title('Share of Wins by Country (Men)')
plt.ylabel('')
plt.show()

# Plot Pie chart for women
wins_country_women.plot(kind='pie', autopct='%1.1f%%', figsize=(8, 8), colors=sns.color_palette("Set2", len(wins_country_women)))
plt.title('Share of Wins by Country (Women)')
plt.ylabel('')
plt.show()

# Count wins and runner-ups for men
country_stats_men = pd.DataFrame({
    'Wins': df_men['Country of Champion'].value_counts(),
    'Runner-ups': df_men['Country of Runner-up'].value_counts()
}).fillna(0)

# Count wins and runner-ups for women
country_stats_women = pd.DataFrame({
    'Wins': df_women['Country of Champion'].value_counts(),
    'Runner-ups': df_women['Country of Runner-up'].value_counts()
}).fillna(0)

# Plot Stacked Bar Chart for men
country_stats_men.plot(kind='bar', stacked=True, figsize=(14, 8), color=['blue', 'orange'])
plt.title('Wins and Runner-Ups by Country (Men)')
plt.xlabel('Country')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

# Plot Stacked Bar Chart for women
country_stats_women.plot(kind='bar', stacked=True, figsize=(14, 8), color=['blue', 'orange'])
plt.title('Wins and Runner-Ups by Country (Women)')
plt.xlabel('Country')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

# Export df_men as a CSV file
df_men.to_csv('WimbledonMensSinglesChampionsOpenEra.csv', index=False)

# Export df_women as a CSV file
df_women.to_csv('WimbledonWomensSinglesChampionsOpenEra.csv', index=False)